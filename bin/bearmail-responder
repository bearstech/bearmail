#!/usr/bin/perl -w

# Copyright (C) 2009 Bearstech - http://bearstech.com/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# bearmail-responder - part of bearmail
#
# Test me with:
# ./autoresponder.pl bot@server me@mail.com test/responder.txt <test/sample.txt

use strict;
use Mail::Sendmail;
 
my $respond_from = $ARGV[1];
my $respond_to = $ARGV[2];
my $responder_file = $ARGV[3]; #"/responder.$respond_from";
my $autoresponder = "no";
my $inmail_headers = "";
my $inmail_from;
my $inmail_subject;
my $inmail_id;

while (<STDIN>) {
  last if /^$/; # Une ligne vide: fin des entetes
  $inmail_headers .= $_;
}

# on va trier les headers
  $inmail_headers =~ s/\?=\s\n/\?=\n/g; # on vire les lignes qui se finissent avec un mot encodé qui ont un espace suplémentaire à la fin
  $inmail_headers =~ s/\n[\s\t]//g; # on aligne en une ligne les parties principales
  $inmail_headers =~ s/,/ /g; # on remplace les virgules par des espaces

foreach (split(/\n/, $inmail_headers)) { # on va chercher dans le header ^^ ah! header si recherché..
 if (m/^To:.*[<\s]$respond_from[>\s].*/i) { # on regarde si dans le To: il y a bien notre adresse
   $autoresponder = "yes";
 }
 if (m/^Content-Type:.*multipart\/report.*/i) { # en cas de mail d'info d'erreur, ne pas envoyer de mail
   exit 0;
 }
 if (m/^Subject: (.*)/i) { # on récupère le sujet
   $inmail_subject = $1;
 }
 if (m/^message-id: (.*)/i) { # on récupère l'id
   $inmail_id = $1;
 }
 if (m/^from:.*[<\s]$respond_from[>\s].*/i) { # on regarde si le from n'est pas notre adresse
   exit 0;
 }
 if (m/^from: (.*)/i) { # on récupère l'adresse du futur destinataire
   $inmail_from = $1;
 }
 if (m/^In-Reply-To: /i) { # si c'est un reply, on n'envoie pas de mail histoire de ne pas faire de yoyo entre répondeur ? essayer de trouver une solution du genre ...
   exit 0;
 }
}

if ($autoresponder ne "yes") { exit 0; }

open(F_RBM, "<$responder_file") || die "Can't read $responder_file \n"; # on récupère le message à envoyer
 my @responder_body = <F_RBM>; # on enregistre son contenu dans @responder_body
close F_RBM;

my $responder_message = join ("\n","@responder_body","");
   $responder_message =~ s/\n /\n/g;

# used to debug:
# cat mail_file|./autoresponder.pl fake_arg mail_of_det mail_of_user_autoresponder
#print "\n### Arguments ###\n";
#print "0 = $ARGV[0]\n";
#print "1 = $respond_from\n";
#print "2 = $respond_to\n";
#print "\n### Info from the received mail ###\n";
#print "From: \"".$inmail_from."\"\n";
#print "Subject = \"".$inmail_subject."\"\n";
#print "ID = \"".$inmail_id."\"\n";
#print "\n### Show the mail to send ###\n";
#print "To : \"$inmail_from\"\n";
#print "From: \"$respond_from\"\n";
#print "Subject: \"$inmail_subject\"\n";
#print "In-Reply-To: \"$inmail_id\"\n";
#print "Content-Type: text/plain; charset=\"utf-8\"\n";
#print "X-Mailer: \"Bearmail autoreply system\"\n\n";
#print "$responder_message\n";

# on créé le mail :
my %mail = (
  To      => "$inmail_from",
  From    => "$respond_from",
  Subject => "$inmail_subject",
  'In-Reply-To' => "$inmail_id",
  'Content-Type' => 'text/plain; charset="utf-8"',
  'X-Mailer' => "Bearmail autoreply system",
  );

$mail{smtp} = '127.0.0.1';
$mail{'message : '} = "$responder_message";

if (sendmail %mail) { }
else { print "Error sending mail: $Mail::Sendmail::error \n" }
